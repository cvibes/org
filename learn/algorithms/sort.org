#+TITLE: Sorting

* Foundation

The =sort= method will only refer to data through =less= and =exch=, listed below. Restriction
data access to these two operations makes our code readable and portable, and makes it easier for
us certify that algorithms are correct, to study performance and to compare algorithms. 

When studying sorting algorithms, we count /compares/ and /exchanges/. For algorithms that do not
use exchanges, we count /array accesses/.

#+BEGIN_SRC java
private static boolean less(Comparable v, Comparable w)
{
    return v.compareTo(w) < 0;
}

private static void exch(Comparable[] a, int i, int j)
{
    Comparable t = a[i];
    a[i] = a[j];
    a[j] = t;
}
#+END_SRC

* Elementary sort

** Selection Sort

First, find the smallest item in the array and exchange it with the first entry. Then find the next smallest
item and exchange it with the second entry. Continue until the entire array is sorted.

*** Code

#+BEGIN_SRC java
/**
 * Algorithm 2.1 Selection Sort
 */
public class Selection
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for (int i = 0; i < N; i++){
            int min = i;
            for (int j = i + 1; j < N; j++)
                if (less(a[j], a[min]) ) min = j;
        }
        exch(a, i, min);
    }
}
#+END_SRC

*** Performance

Uses ~N^2/2 compares and N exchanges to sort an array of length N.

For each item from 0 to i-1, there's one exchange and N-i-1 compares.

*Running time is insensitive to input*.  Each pass has to go through all remaining items to find 
next smallest item.

*Data movement is minimal.*  Number of exchanges is a linear function of the array size, each pass
exchange once. 

** Insertion Sort

Consider each item and move it into its proper place among the already considered.

*** Code

#+BEGIN_SRC java
/**
 * Algorithm 2.2 Insertion Sort
 */
public class Insertion
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for (int i = 1; i < N; i++)
            for (int j = i; j > 0 && less(a[j], a[j-1]); j--)
                exch(a, j, j-1);
    }
}
#+END_SRC

*** Performance

Uses ~N^2/4 compares and ~N^2/4 exchanges to sort array of lenght N on average. Worst case
is ~N^2/2 compares and ~N^2/2 exchanges; best case is N-1 compares and 0 exchanges.

 - On a sorted array or if all keys are same, insertion sort takes /linear/ time.
 - On a /partially sorted/ array (where number of inversions is less than a constant multiple of size), insertion
   sort is efficient. Partially sorted array includes:
   - each entry is not far from its final position
   - a small array appended to a large sorted array.
   - only a few entries that are not in place.
 - Insertion works well for arrays of small size, or partially sorted arrays even if it's huge.

** Shell Sort

Shell sort is an extension of insertion sort that gains speed by allowing exchanges
of array entries that are far apart, to produce partially sorted arrays that can be
efficiently sorted, eventually by insertion sort.

The idea is to rearrange the array to give it the property that taking every /h/th
entry (starting anywhere) yields a sorted subsequence. Such an array is said to be
/h/-sorted. By /h/-sorting for some large values of /h/, we can move items in the
array long distances and thus make it easier to /h/-sort for smaller values of
/h/. Using such a procedure for any sequence of values of /h/ that ends in 1 will
produce a sorted array: this is shellsort.

*** Code

#+BEGIN_SRC java
/**
 * Algorithm 2.3 Shellsort
 */

public class Shell
{
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        int h = 1;
        while ( h < N/3 ) h = 3 * h + 1;   // 1, 4, 13, 40, 121, 364, 1003...
        while ( h >= 1){
            for (int i = h; i < N; i++) Insert a[i] among a[i-h], a[i-2*h], a[i-3*h]...
                for( int j = i; j >= h && less(a[j], a[j-h]); j -= h; )
                    exch(a, j, j-h);
        }
        h = h/3;
    }
}
#+END_SRC

*** Performance

Shellsort is much faster than insertion sort and selection sort, the its speed advantage increases
with the array size. But its exact running time is hard to analyze. It's better than quadratic, the 
worst case number of compares is proportional to N^3/2.


* Merge Sort

/Merge sort/ is based on /merging/: combining two ordered arrays to make one larger ordered array.
This naturally leads to a recursive solution: to sort an array, divide it into halves, sort the two
halves recursively, and then merge the results. It guarantees to sort any array of N items in time
proprotional to /NlogN/. Its prime disadvantage is that it uses extra space proportional to /N/.

** Top-down merge sort

#+BEGIN_SRC java
/**
 * Algorithm 2.4 Top-down merge sort
 */
public class Merge
{
    private static Comparable[] aux;     // auxiliary array for merges

    private static void merge(Comparable[] a, int lo, int mid, int hi)
    {   // Merge a[lo .. mid] with a[mid+1 .. hi]
        int i = lo, j = mid + 1;
        for (int k = lo; k <= hi; k++)    // Copy a[lo .. hi] to aux[lo .. hi]
            aux[k] = a[k];

        for( int k = lo; k <= hi; k++ )
            if      (i > mid)              a[k] = aux[j++];
            else if (j > hi)               a[k] = aux[i++];
            else if (less(aux[j], aux[i])) a[k] = aux[j++];
            else                           a[k] = aux[i++];
    }

    public static void sort(Comparable[] a)
    {
        aux = new Comparable[a.length];   // allocate space just once
        sort(a, 0, a.length - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi)
    {   // sort a[lo..hi]
        if ( hi <= lo ) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid+1, hi);
        merge(a, lo, mid, hid);
    }
}
#+END_SRC

** Bottom-up merge sort

#+BEGIN_SRC java
/**
 *  Bottom-up Merge Sort
 */
public class MergeBU
{
    private static Comparable[] aux;
    // merge code see above
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        aux = new Comparable[N];
        for (int sz = 1; sz < N; sz = sz + sz)
            for (int lo = 0; lo < N-sz; lo += sz + sz)
                merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));
    }
}

#+END_SRC

** Performance

Both top-down and bottom-up merge sort use between 1/2 * NlgN and NlgN compares and
at most 6NlgN array accesses to sort an array of length N.
